package valkey

import (
	"context"
	"errors"
	"fmt"
	"strconv"

	"github.com/oklog/ulid/v2"
	openfgav1 "github.com/openfga/api/proto/openfga/v1"
	"github.com/openfga/openfga/pkg/storage"
	"github.com/redis/go-redis/v9"
	"google.golang.org/protobuf/encoding/protojson"
)

const (
	modelsIndexPrefix = "models:index"
)

func modelsIndexKey(storeID string) string {
	return fmt.Sprintf("%s:%s", modelsIndexPrefix, storeID)
}

func (s *ValkeyBackend) ReadAuthorizationModel(ctx context.Context, store string, id string) (*openfgav1.AuthorizationModel, error) {
	ctx, span := tracer.Start(ctx, "valkey.ReadAuthorizationModel")
	defer span.End()

	// If ID is empty, find latest
	if id == "" {
		return s.FindLatestAuthorizationModel(ctx, store)
	}

	val, err := s.client.Get(ctx, authorizationModelKey(store, id)).Bytes()
	if err != nil {
		if err == redis.Nil {
			return nil, storage.ErrNotFound
		}
		return nil, err
	}

	var model openfgav1.AuthorizationModel
	if err := protojson.Unmarshal(val, &model); err != nil {
		return nil, err
	}

	return &model, nil
}

func (s *ValkeyBackend) ReadAuthorizationModels(ctx context.Context, store string, options storage.ReadAuthorizationModelsOptions) ([]*openfgav1.AuthorizationModel, string, error) {
	ctx, span := tracer.Start(ctx, "valkey.ReadAuthorizationModels")
	defer span.End()

	offset := int64(0)
	if options.Pagination.From != "" {
		o, err := strconv.ParseInt(options.Pagination.From, 10, 64)
		if err != nil {
			return nil, "", storage.ErrInvalidContinuationToken
		}
		offset = o
	}

	count := int64(storage.DefaultPageSize)
	if options.Pagination.PageSize > 0 {
		count = int64(options.Pagination.PageSize)
	}

	// We want descending order (Newest to Oldest)
	// ZREVRANGE key start stop
	// start = offset, stop = offset + count - 1
	ids, err := s.client.ZRevRange(ctx, modelsIndexKey(store), offset, offset+count-1).Result()
	if err != nil {
		return nil, "", err
	}

	if len(ids) == 0 {
		return nil, "", nil
	}

	var modelKeys []string
	for _, id := range ids {
		modelKeys = append(modelKeys, authorizationModelKey(store, id))
	}

	vals, err := s.client.MGet(ctx, modelKeys...).Result()
	if err != nil {
		return nil, "", err
	}

	var models []*openfgav1.AuthorizationModel
	for _, val := range vals {
		if val == nil {
			continue
		}
		sStr, ok := val.(string)
		if !ok {
			continue
		}
		var m openfgav1.AuthorizationModel
		if err := protojson.Unmarshal([]byte(sStr), &m); err != nil {
			return nil, "", err
		}
		models = append(models, &m)
	}

	contToken := ""
	// If we got a full page, return next offset
	if len(ids) == int(count) {
		contToken = strconv.FormatInt(offset+count, 10)
	}

	return models, contToken, nil
}

func (s *ValkeyBackend) FindLatestAuthorizationModel(ctx context.Context, store string) (*openfgav1.AuthorizationModel, error) {
	ctx, span := tracer.Start(ctx, "valkey.FindLatestAuthorizationModel")
	defer span.End()

	id, err := s.client.Get(ctx, latestAuthorizationModelKey(store)).Result()
	if err != nil {
		if err == redis.Nil {
			return nil, storage.ErrNotFound
		}
		return nil, err
	}

	return s.ReadAuthorizationModel(ctx, store, id)
}

func (s *ValkeyBackend) WriteAuthorizationModel(ctx context.Context, store string, model *openfgav1.AuthorizationModel) error {
	ctx, span := tracer.Start(ctx, "valkey.WriteAuthorizationModel")
	defer span.End()

	id := model.GetId()
	if id == "" {
		return errors.New("model ID required") // Should be generated by caller usually? No, OpenFGA caller generates it.
	}

	bytes, err := protojson.Marshal(model)
	if err != nil {
		return err
	}

	// Calculate score from ULID
	ulidID, err := ulid.Parse(id)
	if err != nil {
		return err
	}
	score := float64(ulidID.Time())

	pipeline := s.client.TxPipeline()
	pipeline.Set(ctx, authorizationModelKey(store, id), bytes, 0)
	pipeline.Set(ctx, latestAuthorizationModelKey(store), id, 0)
	pipeline.ZAdd(ctx, modelsIndexKey(store), redis.Z{
		Score:  score,
		Member: id,
	})

	_, err = pipeline.Exec(ctx)
	return err
}
